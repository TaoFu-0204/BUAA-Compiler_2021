# <center>编译技术设计文档</center>

<center>18375200 刘裕炜</center>

## 一、词法分析

### 程序架构

* `Exceptions/LexicalException.java`
  * 异常类，用于词法分析时记录遇到的错误，为后续的错误处理留下可能的接口。
  * 唯一的属性为`lineNum`，在抛出时记录当前错误行号。
  
* `SyntaxClasses/Token.java`
  * 38个常量，代表38种Token类型。
  * 常量数组`typeNames`，为每种类型对应的名称，输出时用。
  
  * 属性`type`， `int`类型，记录当前Token类型；
  * 属性`lineNo`，`int`类型，记录该Token出现的行号；
  * 属性`context`，`String`类型，记录该Token实际代表的字符串。
  * 方法`toString`，用于输出调用，输出词法分析题目所需的内容。
  
* `ReadFile.java`

  * 属性`fileInputStream`，`FileInputStream`类型，用于作为文件输入流；
  * 属性`filePath`，`String`类型，用于提供读入文件地址。
  * 构造方法带一个`String`类型参数，指明待读取的文本文件地址。
  * 方法`readFile()`，返回`StringBuilder`类型，用于读取代码并消除注释。

* `LexicalAnalyzer.java`

  * 属性`progranStr`，`StringBuilder`类型，为待分析的程序代码；
  * 属性`tokenList`，`Linkedlist<SyntaxClasses.Token>`类型，为处理过程中以及最后将返回的按序存储Token的链表。
  * 构造方法。
  * 方法`setProgramStr(StringBuilder programStr)`，设置`programStr`属性，即导入程序文本。
  * 方法`getTokenList()`，返回已处理好的Token链表。
  * 方法`isDigit(char c)`，判断`c`是否为0~9的数字字符。
  * 方法`isIdentNonDigit(char c)`，判断`c`是否为大小写字母或下划线。
  * 方法`isIdentChar(char c)`，判断`c`是否为Ident中允许出现的字符类型。
  * 方法`isSpace(char c)`，判断`c`是否为有效空白符。
  * 方法`lexicalAnalyze()`，执行词法分析，生成Token链表。
  * 方法`identAnalyze(int lineNum, String identStr)`，分析当前字符串是保留字还是Ident。

### 实现流程

#### 去除注释

先将整个代码扫描一遍，将所有`//`及其到行尾之间的内容，以及所有`/*`和`*/`之间的内容均替换为空格。此步去除所有注释内容。

#### 词法分析

将38种Token分为如下几类：
* 单字符类

| `+`  | `-`  | `*`  | `/`  | `%`  | `;`  | `,`  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `(`  | `)`  | `[`  | `]`  | `{`  | `}`  |      |

该类共13种Token，每种Token均不为其它任一中Token的前缀。因此，在词法分析程序遇到该类字符时，立刻可以将其识别为相应的Token类型。

* 双字符及其前缀类

| `!`  | `>`  | `<`  | `=`  | `&`  | `|`  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| `!=` | `>=` | `<=` | `==` | `&&` | `||` |

该类共6对，12种Token。可以看出，首行每个Token都是次行相应Token的前缀，因此在读取到首行的字符时，需要再尝试读取一次后面紧接着的一个字符，以确定它是单个出现还是和后面紧跟着的符号一起构成一个Token。

* 格式字符串**FormatString**

以`"`开头，以`"`结尾的字符串。在读取到一个`"`时，直接向后查找到下一个`"`字符或文件结尾。若找到下一个`"`，则两个`"`及它们之间的所有内容为一个格式字符串。若找不到，则显然有双引号不匹配，抛出错误。

* 整常数**IntConst**

全为数字的字符串。判断方法为在开头读取到一个数字字符后，将所有连续的数字字符均算入。

* 标识符和英文保留字

在排除以上所有情况之后，若读取到一个`a`-`z`，或`A`-`Z`或`-`，则一路向后读取所有`a`-`z`，`A`-`Z`，`0`-`9`或`-`。此类标识符在确定其内容后，再去尝试匹配各个英文保留字，若均无法匹配，则认为是一个标识符。

### 设计修改

* 在去除注释时，发现需要考虑`//`、`/*`、`*/`在格式字符串内的情况，因此增加了检测`"`的部分。

## 二、语法分析

### 程序架构

`Exceptions/SyntaxException.java`

* 异常类，用于语法分析时记录遇到的错误，为后续的错误处理留下可能的接口。
* 目前唯一的属性为`lineNum`，在抛出时记录当前错误行号。

`SyntaxClasses/SyntaxClass.java`

* 非终结符语法成分类。
* 33个常量，表明32种非终结符类型和终结符`Token`，并将词法分析的`Token`类设置为继承自`SyntaxClass`类。
* 常量数组`syntaxNames`用于标识该语法成分名，用于输出。
* 属性`type`， `int`类型，记录当前语法成分类型。
* 属性`lineNo`，`int`类型，记录该语法成分出现的行号。
* 属性`sonNodeList`，`LinkedList<SyntaxClass>`类型，按从左往右顺序记录该语法成分推导得出的成分。
* 构造方法`SyntaxClass(int syntaxType)`，接受`int`类型参量，用于构造一个类型为传入类型的空语法成分。
* 方法`appendSonNode(SyntaxClass sonNode)`，将建立好的子成分加入当前成分的`sonNodeList`末尾。
* 方法`setFirstAsLineNo()`，将该语法成分的行号设置为第一个子成分的行号。
* 方法`toString()`，重写原函数，按`sonNodeList`内顺序输出各子成分后，在最后输出当前成分名。

`SyntaxAnalyzer.java`

* 语法分析器类。
* 属性`tokenList`，`ArrayList<Token>`类型，为词法分析得到的`Token`序列。
* 属性`globalCompUnit`，`SyntaxClass`类型，全局唯一的编译单元。
* 属性`pos`，`int`类型，下一个待读取的`Token`位置。
* 对每一个非终结符$A$，有方法`readA()`，返回类型`SyntaxClass`，作用是读取一个$A$成分并返回它。

### 实现流程

语法分析器整体采用递归下降的流程。

通过尽可能地拆分文法内多个可选成分以尽可能减少回溯，如在成分`Stmt`推导时，检测下一个`Token`的情况，若为`if`则直接转对if语句读取，若为`return`则转对return语句读取，若为`printf`则转对printf语句读取等。

对于部分左递归文法，如各种表达式，改写为非递归文法以避免死循环。

对于任一语法成分，若匹配成功则返回该语法成分的描述结构，否则若`pos`越界，返回`null`，其它情况抛出异常。对于需要回溯的情况，提前存储`pos`指针位置，若出现异常则捕获异常，并回退`pos`，执行其它分支。

### 设计修改

* 为通过评测，发现原有的设计中，将左递归文法改写为非递归文法后，按改写的文法执行递归下降，建立的语法树等价但不符合输出要求。如5个式子连乘，要求的文法需要做成高度为6的二叉树，但修改文法后可以做到两层的多叉树，这导致输出时结构与期待结构有差异，因此需要重新在树中建立左递归的结构。解决方案是在处理左递归时先按照改写文法处理，但在发现右侧还有成分时，先将左侧向上打包一层，构造出原文法所要求的左递归结构。

* 原本设计时，语法分析器`SyntaxAnalyzer`接受的是词法分析器产生的`LinkedList<Token>`类型的`Token`链表，但考虑到语法分析器内需要频繁按下标顺序读取、回溯，在构造时将链表转换为了`ArrayList<Token>`类型的数组以减少查询时间复杂度。

## 三、错误处理

### 程序架构

`Symbols/Symbol.java`

* 符号类

* 属性`token`，`Token`类型，该符号对应的Token。
* 属性`name`， `String`类型，该符号的名称。
* 属性`type`，`int`类型，该符号的类型。

`Symbols/FuncSymbol.java`

* 继承自`Symbol`类，为函数对应的符号类。
* 属性`hasReturn`，`boolean`类型，表示该函数是否有返回值。
* 属性`fParams`，`ArrayList<SymbolType>`类型，表示该函数参数类型列表。
* 方法`addFormalParanType`，根据参数不同重载了两种实现，用于向函数符号添加形参类型。
* 方法`checkParamsLength(FuncSymbol func)`，检查当前函数符号与参数中符号的形参数量是否相等。
* 方法`checkConsistent(FuncSymbol func)`，检查当前函数符号与参数中符号的参数类型是否一致。

`Symbols/VarSymbol.java`

* 继承自`Symbol`类，为常、变量对应的符号类。
* 属性`varType`，`varType`类型，表示该常/变量的类型。
* 属性`dimLength`，`int[]`类型，表示若为数组，各维度长度。
* 方法`isVar()`，检查其是否为变量。
* 方法`getDimType()`，检查其维度情况。
* 方法`getDimLength(int dim)`，检查其第$dim$维的长度。

`Symbols/SymbolType.java`

* 常/变量符号对应的类型类
* 属性`dimType`， `int`类型，表示其维度情况。
* 属性`isVariable`，`int`类型，表示其是否为变量。

* 方法`isVar()`，检查其是否为变量。
* 方法`getDimType()`，检查其维度情况。

`Symbols/SymbolTable.java`

* 符号表类。
* 属性`parent`，`SymbolTable`类型，该符号表的上级符号表。
* 属性`varSymbolMap`，`HashMap<String, VarSymbol>`类型，变量符号容器。
* 属性`funcSymbolMap`，`HashMap<String, FuncSymbol>`类型，函数符号容器。
* 属性`cycleBlock`，`boolean`类型，标志是否在循环内。
* 属性`curFunc`，`FuncSymbol`类型，若当前块为函数直接块则指向该函数，否则为空。
* 方法`localLookup(String name)`，检查当前表内是否有名为`name`的符号。
* 方法`globalLookup(String name)`，检查当前表及其一路上溯至全局表内是否有名为`name`的符号。
* 方法`addSymbol(Symbol symbol)`，向该符号表中添加符号。
* 方法`isInCycleBlock()`，检查该块是否在循环内。
* 方法`checkCurFunc()`，检查该块所在的函数。

`Symbols/SymbolAnalyzer.java`

* 符号分析器类。
* 方法`getFuncSymbol(SyntaxClass funcDef)`，静态方法，从`FuncDef`语法成分中读取一个函数符号。
* 方法`getCallFuncSymbol(SyntaxClass unaryExp)`，静态方法，从`UnaryExp`且已确定为是函数调用的语法成分中读取一个函数符号。

`Exceptions/DuplicatedDefineIdentException.java`

* 重定义异常

`Exceptions/LValNotDefinedException.java`

* `LVal`内未定义符号异常

### 实现流程

#### 符号表结构

![](符号表结构.png)

符号表体系结构的设计参考了*Compilers: Principles, Techniques and Tools*一书中的设计。每一级一张独立的符号表，其`parent`指向其直接上一级符号表。全局符号表的`parent`指向`null`。

如此设计可以保证每次在一张符号表上能且只能看见该符号表本身及所有该符号表从属的符号表，看不见与其没有直接隶属关系的符号表。且在递归下降分析时，这类单向树符号表的行为与栈类似，能很好适应递归下降时的符号表操作。

在加入符号时，符号表仅扫描本表内是否有重名变量。在查找符号时，从本级开始逐级向上查找，找到最近的一个即可。这就满足了内部符号覆盖外部符号的要求。

#### 错误处理实现

| 错误类型 | 处理实现 |
| -------- | -------- |
| 非法符号 | 词法分析时检测到`FormatString`时就检测是否有非法字符，若有，则将错误加入错误列表。 |
|名字重定义|检测到当前是定义类型的语法成分时，将相应Token的内容在当前符号表内查询，若查询到有效记录则报错。|
|未定义名字|在`LVal`和`UnaryExp`检测到标识符时，在当前符号表要求全局查询，若查找不到则报错。|
|函数参数个数不匹配|在检查到函数调用时，确认函数符号有效及函数内各参数有效后，生成函数调用参量类型表，调用被调函数的符号的检查模块，检查参数个数是否匹配。|
|函数参数类型不匹配|完成参数个数检测且未报错后，调用被调函数的符号的检查模块，检查参数类型是否匹配。|
|无返回值函数存在不匹配return语句|检查到当前语句为return，则从符号表检查当前所在函数类型，然后与return类型比较，若不匹配，则报错。|
|有返回值函数缺少return语句|在执行完一次对`FuncDef`的读取后，若该函数为有返回值函数，则检查`Block`的最后一项语法成分是否为return语句。|
|改变`LVal`常量值|检查到对`LVal`赋值的语句，则去符号表中检查该`LVal`对应的Token，若为常量则报错。|
|缺少分号|递归下降检查时若在该出现分号时没有分号则报错。|
|缺少右小括号|递归下降检查时若在该出现右小括号时没有右小括号则报错。|
|缺少右中括号|递归下降检查时若在该出现右中括号时没有右中括号则报错。|
|printf中格式字符与表达式个数不匹配|在词法分析时就检查格式字符串中格式字符数，在读取到printf时检查后面表达式的数量是否与格式字符数匹配。|
|非循环块中使用break或continue|检查到break或continue时，在符号表中检查当前是否在循环块内，若不在则报错。|

### 设计修改

在存在回溯的递归下降部分，若简单地在产生错误处直接进行处理，会导致回溯后多次报告同一错误，因此在对如`LVal`等部分进行错误处理时，不再直接处理，而是记录错误情况，作为`Exception`抛出，交给上一层逻辑判断是否将本次报错加入已检测的错误列表。

某些部分如缺括号、缺分号之类进行错误处理后，后面的内容会因为检测不到前一处应有的符号而报错，因此在报错的错误处理部分把缺失的符号补回去了。

## 四、代码生成

### 程序架构

`IR/IRSymbol.java`

* 中间代码符号的interface。

`IR/IRImmSymbol.java`

* 中间代码立即数符号，其`value`属性即为该立即数的值。

`IR/IRLabelSymbol.java`

* 中间代码符号，可用于表示变量或地址
* 属性`id`，`int`类型，表示该符号的ID
* 属性`isGlobal`，`boolean`类型，表示是否是全局符号

`IR/IRFuncSymbol.java`

* 中间代码函数符号
* 属性`func`，`String`类型，表示函数名
* 属性`entry`，`IRSymbol`类型，表示函数入口标签
* 属性`fParamList`，`ArrayList<IRSymbol>`类型，表示形参表

`IR/IRArrSymbol.java`

* 中间代码数组元素符号
* 属性`baseAddr`，`IRSymbol`类型，表示基地址
* 属性`offset`，`IRSymbol`类型，表示偏移量

`IR/IRLabelManager.java`

* 中间代码符号管理器
* 属性`instance`，`IRLabelManager`类型，为单例模式的唯一实例
* 属性`labelMap`，`HashMap<Integer, IRLabelSymbol>`类型，记录其发放管理的符号ID和符号本身的关系
* 属性`cnt`，`int`类型，记录下一个发放符号的ID
* 方法`getIRLabelManager()`，单例模式下获取实例方法
* 方法`allocSymbol()`，向该管理器申请一个新符号，管理器返回一个新符号并记录该符号ID，然后将cnt自增1。

`IR/CompUnitSimplifyer.java`

* 表达式常量化简类

* 递归地查找`CompUnit`中的常量成分，并将其逐层计算得到常量部分的值

`IR/IRTranslater.java`

* 语法树到中间代码的翻译器

* 对各个语法成分有相应的分析方法
* 最终得到一列中间代码和全局数据信息

`FunctionTemplate.java`

* 运行时函数模板
* 用于确定该函数所需空间，以动态地调整运行时栈的位置
* 方法`getSymbolOffset`，接受一个符号，返回该符号在函数运行时相对于栈顶的偏移
* 方法`getTemplateSize`，返回该函数所需的空间大小，以字节为单位

`MIPSTranslater.java`

* 中间代码到MIPS目标代码的生成器
* 方法`buildFunctionTemplate`，对中间代码进行扫描，建立起各函数的模板
* 对各类中间代码指令的翻译方法

### 中间代码设计

#### 算术指令（允许立即数）

| 指令                             | 用途               |
| -------------------------------- | ------------------ |
| add \<dest\> \<op1\> \<op2\>     | op1 + op2          |
| minu \<dest\> \<op1\> \<op2\>    | op1 - op2          |
| mult \<dest\> \<op1\> \<op2\>    | op1 * op2          |
| div \<dest\> \<op1\> \<op2\>     | op1 / op2（整除）  |
| mod \<dest\> \<op1\> \<op2\>     | op1 % op2（取模）  |
| assign  \<dest\> \<op1\>         | dest = op1（赋值） |
| lshift \<dest\> \<op1\> \<op2\>  | op1 << op2         |
| rshift \<dest\> \<op1\> \<op2\>  | op1 >> op2，逻辑   |
| rashift \<dest\> \<op1\> \<op2\> | op1 >> op2，算术   |
| and \<dest\> \<op1\> \<op2\>     | op1 & op2          |

#### 逻辑指令

| 指令                          | 用途       |
| ----------------------------- | ---------- |
| gre  \<dest\> \<op1\> \<op2\> | op1 > op2  |
| geq  \<dest\> \<op1\> \<op2\> | op1 >= op2 |
| lss  \<dest\> \<op1\> \<op2\> | op1 < op2  |
| leq  \<dest\> \<op1\> \<op2\> | op1 <= op2 |
| eql  \<dest\> \<op1\> \<op2\> | op1 == op2 |
| neq  \<dest\> \<op1\> \<op2\> | op1 != op2 |

#### 控制流

| 指令                               | 用途                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| br \<label\>                       | 无条件跳转至 \<label\>（op3）                                |
| bz \<label\> \<op1\>               | 若op1为0则跳转至\<label\>（op3）                             |
| bnz \<label\> \<op1\>              | 若op1不为0则跳转至\<label\>（op3）                           |
| call \<ret\> \<func> \<ParamList\> | 返回值（op3，可为null），函数调用（op1），带参数列表（可空） |
| setret \<op3\>                     | 设置为返回值                                                 |
| ret                                | 函数返回                                                     |
| exit                               | main函数结束，程序结束                                       |

#### 内存操作

| 指令                          | 用途                                         |
| ----------------------------- | -------------------------------------------- |
| load \<op3\> \<op1\> \<op2\>  | 从op1为基地址，op2为偏移量处取值送op3        |
| store \<op3\> \<op1\> \<op2\> | 向op1为基地址，op2为偏移量处存op3            |
| alloca \<dest\> \<op1\>       | 开辟op1字节大小空间，基地址送dest（int需*4） |

#### 输入输出

| 指令               | 用途                        |
| ------------------ | --------------------------- |
| getint \<dest\>    | dest=getint()               |
| prints \<strdest\> | printf，带字符串地址（op3） |
| prints \<op3\>     | printf，带整数（op3）       |

#### 其他

| 指令                        | 用途                        |
| --------------------------- | --------------------------- |
| #\<id\>                     | 中间变量，编号为id          |
| func \<name\> \<paramlist\> | 函数定义（op3），带参数列表 |
| label \<LabelName\>         | 标签（op3）                 |

### 实现流程

在语法类中添加了标志是否进行求值的位和常量求值结果。在执行代码生成前，先使用`CompUnitSimplifyer`类对整个语法树递归地进行一次常量求值化简，可以得到各常量的值、数组大小等信息。

`IRTranslater`类是语法树到中间代码的翻译器。在`IRTranslater`中，翻译器维护了常量数组、全局变量、格式字符串和函数名与中间代码符号的映射表。同时还在前述符号表中维护了变量符号与对应的中间代码符号映射。

在每次读取到全局变量定义或局部数组定义时，插入申请空间的中间指令（`ALLOCA`）并将得到的基地址符号在相应映射表中记录。读取到函数定义时，在函数映射表中作记录。

在每次读取到变量被使用时，在当前符号表中检查是否已经有该变量对应的中间代码符号，若没有则申请一个新的。每次读取到变量被赋值或初始化时，若未开启SSA，则检查符号表是否有该符号，有就用原来的，没有则申请新的；若已开启SSA，则直接申请新符号并更新符号表中该变量对应的符号。

对于数组元素，设置了`IRArrSymbol`来表示数组元素。每次检测到对数组元素的使用，就在相应的表中查询数组符号，并计算得到表示偏移的符号，拼在一起作为一个`IRArrSymbol`实例使用。

对于普通的控制结构，参照语法制导翻译部分的方法，在相应位置插入中间代码符号，以一条`LABEL`类指令作为跳转地址标签。然后在相应的位置插入相应的跳转语句。

对于函数调用，在调用前按顺序插入计算各参数的指令，然后加入`CALL`指令，带上参数、函数名和返回值。

对于`printf`，在词法分析阶段建立格式字符串时已经将各部分划分好，因此直接将纯字符串部分和格式字符部分拆开，拆成对字符串的输出和对格式字符变量（整数）的输出，同时将字符串加入全局变量区。

对于条件语句，需要遵循短路求值的原则。因此，我实际上将复合的条件语句展开为了一段过程以及一个返回值。首先计算第一个条件，若第一个条件满足短路求值的要求，则跳转到设置返回值为1的部分，否则计算第二个条件，并跳转至设置相应返回值部分。

在代码生成作业阶段，为及时完成作业，中间代码到目标代码的转换，采用了简单的固定寄存器功能的方法。对于算术指令和逻辑运算指令，规定`$t0`为结果寄存器，`$t1`、`$t2`为运算数寄存器；对于读写内存，固定采用op3、op1、op2分别为`$t0`、`$t1`、`$t2`。输入输出均使用`$t0`寄存器；函数调用统一采取从调用栈中读取的方式。每次修改完某变量的值，立刻写回内存。

### 设计修改

最初未考虑短路求值，专门设计了位运算来判断条件。后来在输出代码的时候意识到短路求值不能依靠位运算实现，所以重新修改了短路求值的方法，改为逐条件判断。

原计划做成SSA，后来发现分支结构难以实现，最终在无分支的地方尽可能采取单赋值，有分支的地方复用变量。

## 五、代码优化

### 程序架构

`Optimizer/BasicBlock.java`

* 基本块类
* 包含基本块内指令列表、基本块的前驱、后继、各类数据流分析相关集合

`Optimizer/DAG/DAGNode.java`

* DAG图节点类

`Optimizer/DAG/DAGCallNode.java`

* DAG图函数调用节点类，上述节点类的子类，用于表示函数调用

`Optimizer/DAG/DAGClass.java`

* DAG图类，包括节点列表及添加、导出方法

`Optimizer/ConstSpread.java`

* 常量传播模块
* 采用前向数据流分析，迭代到确定每个变量是否为常量为止

`Optimizer/ConstSpreadType.java`

* 常量传播类型模块
* 分为未知`UNDEF`、常量`CONST`、非常量`NAC`三种
* 若为常量，则再记录常量值

`Optimizer/JumpOpt.java`

* 连续跳转优化模块
* 优化直接跳转到下一条指令的中间代码

`Optimizer/LiveVarAnalysis.java`

* 活跃变量分析模块
* 采用逆向数据流分析，迭代得到最终`in`和`out`集合结果

`Optimizer/MultDivOpt.java`

* 乘除优化

* 将乘、除、模2的幂次的操作进行优化

`Optimizer/PrintOpt.java`

* 输出优化

* 删除输出空串的地方

`Optimizer/IROptimizer.java`

* 中间代码优化模块调度
* 负责建立基本块，安排各优化模块执行

`MIPSTranslatorWithReg.java`

* 带寄存器分配的中间代码到MIPS目标代码的生成器

### 实现流程

在中间代码生成和目标代码生成之间加入代码优化。主要实现内容为：

#### 窥孔优化

* 乘除模2的幂次时改为左右移和取低位
* 无条件跳转到下一条指令，则删除这条跳转
* 输出字符串若为空，则删除该输出语句

#### 基本块建立与处理

按照跳转指令、跳转目标、函数结束指令的位置划分基本块，但不考虑函数调用，将函数调用视为普通的，不影响执行顺序的语句。

建立基本块后，检查各基本块结束时转到的地方，建立基本块之间前驱、后继关系。

#### 活跃变量分析

采用教材的活跃变量分析方法，先计算各基本块的`def`和`use`集合，然后迭代计算`in`和`out`集合。

#### 常量传播

通过数据流分析过程，分析各变量的值是否为常量。

若变量涉及getint和从内存取值，则直接认定为`NAC`。若变量在迭代过程中，从两个来源得到的常量值不同，说明变量在中途会被修改，认定为`NAC`。

迭代结束后，将所有确定为常量的变量的**取值使用点**全部替换为相应的值。

#### 基于DAG图的优化

* 采用教材所述方式建立DAG图。

* 为保证内存读写、输入输出、函数调用的执行顺序，将DAG图的二叉树结构扩展为多叉树结构，使得一个节点的执行需要依赖多个节点的执行结果。
* 将函数调用指令按内存写入指令的标准进行处理，以保证函数调用中可能的内存操作的正确性。

* 对于内存读取，在其正常依赖的基础上增加基本块内上一次内存写入（如果有的话），以保证读取到的数据必须为正常修改后的数据。
* 对于内存写入类型，包括函数调用，在正常依赖的基础上增加对上一次内存读写的依赖，保证其执行不会影响到前面所有内存读写操作。
* 对于输入输出，在其正常依赖的基础上增加对上一次输入输出的依赖，以表现出正常的执行顺序。
* 对设置返回值的指令，仅保留最后一条，因为后面的返回值设置显然会覆盖前面的。
* 对于局部公共子表达式，正常的计算指令就按照子节点情况判断。对于内存读取，检查是否已经存在所有依赖情况均相同的读取节点，也就是读取的基地址、偏移量和上一条写入均相同的节点，若存在则说明是公共的。
* 对于内存写入，检查前一条内存访问类指令是否是对同一基地址、偏移量写入，若是，则说明存在两次连续的对同一位置的写入，可以将前一次写入覆盖。
* 从DAG图导出中间指令时，采取深度优先搜索的方式，将需要导出的节点的所有子节点先加入计算列表，最后加入本节点。对于导出结点的选择，首先导出活跃变量分析得到的该基本块出口活跃变量，然后导出最后一条输入输出语句，然后导出最后一条内存写入或函数调用语句，然后如果存在的话，导出设置返回值的语句，以及函数返回或结束语句。剩下的未被导出的语句只可能是该块出口处不活跃的变量赋值，以及读取内存但结束后未使用的语句。这些语句可以删除。对于多各变量指向一个节点，若有活跃变量，则选择一个作为运算结果，其它活跃变量从它处赋值；若无活跃变量，则选择任一不活跃变量；若无变量指向它，则申请一个新变量来表示该节点的运算情况。

#### 目标代码生成

寄存器分配采用较为简单的寄存器池法。在每一个基本块内维护一个寄存器池，每次有变量需要使用寄存器则向寄存器池申请，若有空闲则直接分配，无空闲则优先选择该块内后续不再使用的变量释放寄存器，写回值，然后把寄存器分配给新的变量。保留一个临时寄存器不作分配，用于实在无法分配寄存器时，临时在栈上读写变量用；保留一个寄存器用于在立即数无法被立即数相关指令直接使用时加载该数，如减法中被减数为立即数的情况等。

每次在遇到函数调用或基本块结束时将所有变量全部写回内存，然后复位寄存器池。

在可以通过立即数执行的情况下，尽量采取立即数相关指令。如加一个常数，使用`addiu`而不是单独把常数加载到寄存器。

### 设计修改

原计划采取图着色算法进行全局寄存器分配，后来发现能力有限，无法查清出问题的地方而放弃。

寄存器池写回时发现常量字符串部分被修改，检查后在写回时单独检查该寄存器对于变量是否为全局标签，若为全局标签，则不执行写回，仅放弃寄存器。

执行乘除优化后发现部分乘0，0除以某数等地方被直接优化为0，因此再执行一遍中间代码优化以将这些新产生的常量进行传播。
