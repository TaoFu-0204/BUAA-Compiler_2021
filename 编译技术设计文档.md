# <center>编译技术设计文档</center>

<center>18375200 刘裕炜</center>

## 一、词法分析

### 程序架构

* `Exceptions/LexicalException.java`
  * 异常类，用于词法分析时记录遇到的错误，为后续的错误处理留下可能的接口。
  * 唯一的属性为`lineNum`，在抛出时记录当前错误行号。
  
* `SyntaxClasses/Token.java`
  * 38个常量，代表38种Token类型。
  * 常量数组`typeNames`，为每种类型对应的名称，输出时用。
  
  * 属性`type`， `int`类型，记录当前Token类型；
  * 属性`lineNo`，`int`类型，记录该Token出现的行号；
  * 属性`context`，`String`类型，记录该Token实际代表的字符串。
  * 方法`toString`，用于输出调用，输出词法分析题目所需的内容。
  
* `ReadFile.java`

  * 属性`fileInputStream`，`FileInputStream`类型，用于作为文件输入流；
  * 属性`filePath`，`String`类型，用于提供读入文件地址。
  * 构造方法带一个`String`类型参数，指明待读取的文本文件地址。
  * 方法`readFile()`，返回`StringBuilder`类型，用于读取代码并消除注释。

* `LexicalAnalyzer.java`

  * 属性`progranStr`，`StringBuilder`类型，为待分析的程序代码；
  * 属性`tokenList`，`Linkedlist<SyntaxClasses.Token>`类型，为处理过程中以及最后将返回的按序存储Token的链表。
  * 构造方法。
  * 方法`setProgramStr(StringBuilder programStr)`，设置`programStr`属性，即导入程序文本。
  * 方法`getTokenList()`，返回已处理好的Token链表。
  * 方法`isDigit(char c)`，判断`c`是否为0~9的数字字符。
  * 方法`isIdentNonDigit(char c)`，判断`c`是否为大小写字母或下划线。
  * 方法`isIdentChar(char c)`，判断`c`是否为Ident中允许出现的字符类型。
  * 方法`isSpace(char c)`，判断`c`是否为有效空白符。
  * 方法`lexicalAnalyze()`，执行词法分析，生成Token链表。
  * 方法`identAnalyze(int lineNum, String identStr)`，分析当前字符串是保留字还是Ident。

### 实现流程

#### 去除注释

先将整个代码扫描一遍，将所有`//`及其到行尾之间的内容，以及所有`/*`和`*/`之间的内容均替换为空格。此步去除所有注释内容。

#### 词法分析

将38种Token分为如下几类：
* 单字符类

| `+`  | `-`  | `*`  | `/`  | `%`  | `;`  | `,`  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `(`  | `)`  | `[`  | `]`  | `{`  | `}`  |      |

该类共13种Token，每种Token均不为其它任一中Token的前缀。因此，在词法分析程序遇到该类字符时，立刻可以将其识别为相应的Token类型。

* 双字符及其前缀类

| `!`  | `>`  | `<`  | `=`  | `&`  | `|`  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| `!=` | `>=` | `<=` | `==` | `&&` | `||` |

该类共6对，12种Token。可以看出，首行每个Token都是次行相应Token的前缀，因此在读取到首行的字符时，需要再尝试读取一次后面紧接着的一个字符，以确定它是单个出现还是和后面紧跟着的符号一起构成一个Token。

* 格式字符串**FormatString**

以`"`开头，以`"`结尾的字符串。在读取到一个`"`时，直接向后查找到下一个`"`字符或文件结尾。若找到下一个`"`，则两个`"`及它们之间的所有内容为一个格式字符串。若找不到，则显然有双引号不匹配，抛出错误。

* 整常数**IntConst**

全为数字的字符串。判断方法为在开头读取到一个数字字符后，将所有连续的数字字符均算入。

* 标识符和英文保留字

在排除以上所有情况之后，若读取到一个`a`-`z`，或`A`-`Z`或`-`，则一路向后读取所有`a`-`z`，`A`-`Z`，`0`-`9`或`-`。此类标识符在确定其内容后，再去尝试匹配各个英文保留字，若均无法匹配，则认为是一个标识符。

### 设计修改

* 在去除注释时，发现需要考虑`//`、`/*`、`*/`在格式字符串内的情况，因此增加了检测`"`的部分。

## 二、语法分析

### 程序架构

`Exceptions/SyntaxException.java`

* 异常类，用于语法分析时记录遇到的错误，为后续的错误处理留下可能的接口。
* 目前唯一的属性为`lineNum`，在抛出时记录当前错误行号。

`SyntaxClasses/SyntaxClass.java`

* 非终结符语法成分类。
* 33个常量，表明32种非终结符类型和终结符`Token`，并将词法分析的`Token`类设置为继承自`SyntaxClass`类。
* 常量数组`syntaxNames`用于标识该语法成分名，用于输出。
* 属性`type`， `int`类型，记录当前语法成分类型。
* 属性`lineNo`，`int`类型，记录该语法成分出现的行号。
* 属性`sonNodeList`，`LinkedList<SyntaxClass>`类型，按从左往右顺序记录该语法成分推导得出的成分。
* 构造方法`SyntaxClass(int syntaxType)`，接受`int`类型参量，用于构造一个类型为传入类型的空语法成分。
* 方法`appendSonNode(SyntaxClass sonNode)`，将建立好的子成分加入当前成分的`sonNodeList`末尾。
* 方法`setFirstAsLineNo()`，将该语法成分的行号设置为第一个子成分的行号。
* 方法`toString()`，重写原函数，按`sonNodeList`内顺序输出各子成分后，在最后输出当前成分名。

`SyntaxAnalyzer.java`

* 语法分析器类。
* 属性`tokenList`，`ArrayList<Token>`类型，为词法分析得到的`Token`序列。
* 属性`globalCompUnit`，`SyntaxClass`类型，全局唯一的编译单元。
* 属性`pos`，`int`类型，下一个待读取的`Token`位置。
* 对每一个非终结符$A$，有方法`readA()`，返回类型`SyntaxClass`，作用是读取一个$A$成分并返回它。

### 实现流程

语法分析器整体采用递归下降的流程。

通过尽可能地拆分文法内多个可选成分以尽可能减少回溯，如在成分`Stmt`推导时，检测下一个`Token`的情况，若为`if`则直接转对if语句读取，若为`return`则转对return语句读取，若为`printf`则转对printf语句读取等。

对于部分左递归文法，如各种表达式，改写为非递归文法以避免死循环。

对于任一语法成分，若匹配成功则返回该语法成分的描述结构，否则若`pos`越界，返回`null`，其它情况抛出异常。对于需要回溯的情况，提前存储`pos`指针位置，若出现异常则捕获异常，并回退`pos`，执行其它分支。

### 设计修改

* 为通过评测，发现原有的设计中，将左递归文法改写为非递归文法后，按改写的文法执行递归下降，建立的语法树等价但不符合输出要求。如5个式子连乘，要求的文法需要做成高度为6的二叉树，但修改文法后可以做到两层的多叉树，这导致输出时结构与期待结构有差异，因此需要重新在树中建立左递归的结构。解决方案是在处理左递归时先按照改写文法处理，但在发现右侧还有成分时，先将左侧向上打包一层，构造出原文法所要求的左递归结构。

* 原本设计时，语法分析器`SyntaxAnalyzer`接受的是词法分析器产生的`LinkedList<Token>`类型的`Token`链表，但考虑到语法分析器内需要频繁按下标顺序读取、回溯，在构造时将链表转换为了`ArrayList<Token>`类型的数组以减少查询时间复杂度。

## 三、错误处理

### 程序架构

`Symbols/Symbol.java`

* 符号类

* 属性`token`，`Token`类型，该符号对应的Token。
* 属性`name`， `String`类型，该符号的名称。
* 属性`type`，`int`类型，该符号的类型。

`Symbols/FuncSymbol.java`

* 继承自`Symbol`类，为函数对应的符号类。
* 属性`hasReturn`，`boolean`类型，表示该函数是否有返回值。
* 属性`fParams`，`ArrayList<SymbolType>`类型，表示该函数参数类型列表。
* 方法`addFormalParanType`，根据参数不同重载了两种实现，用于向函数符号添加形参类型。
* 方法`checkParamsLength(FuncSymbol func)`，检查当前函数符号与参数中符号的形参数量是否相等。
* 方法`checkConsistent(FuncSymbol func)`，检查当前函数符号与参数中符号的参数类型是否一致。

`Symbols/VarSymbol.java`

* 继承自`Symbol`类，为常、变量对应的符号类。
* 属性`varType`，`varType`类型，表示该常/变量的类型。
* 属性`dimLength`，`int[]`类型，表示若为数组，各维度长度。
* 方法`isVar()`，检查其是否为变量。
* 方法`getDimType()`，检查其维度情况。
* 方法`getDimLength(int dim)`，检查其第$dim$维的长度。

`Symbols/SymbolType.java`

* 常/变量符号对应的类型类
* 属性`dimType`， `int`类型，表示其维度情况。
* 属性`isVariable`，`int`类型，表示其是否为变量。

* 方法`isVar()`，检查其是否为变量。
* 方法`getDimType()`，检查其维度情况。

`Symbols/SymbolTable.java`

* 符号表类。
* 属性`parent`，`SymbolTable`类型，该符号表的上级符号表。
* 属性`varSymbolMap`，`HashMap<String, VarSymbol>`类型，变量符号容器。
* 属性`funcSymbolMap`，`HashMap<String, FuncSymbol>`类型，函数符号容器。
* 属性`cycleBlock`，`boolean`类型，标志是否在循环内。
* 属性`curFunc`，`FuncSymbol`类型，若当前块为函数直接块则指向该函数，否则为空。
* 方法`localLookup(String name)`，检查当前表内是否有名为`name`的符号。
* 方法`globalLookup(String name)`，检查当前表及其一路上溯至全局表内是否有名为`name`的符号。
* 方法`addSymbol(Symbol symbol)`，向该符号表中添加符号。
* 方法`isInCycleBlock()`，检查该块是否在循环内。
* 方法`checkCurFunc()`，检查该块所在的函数。

`Symbols/SymbolAnalyzer.java`

* 符号分析器类。
* 方法`getFuncSymbol(SyntaxClass funcDef)`，静态方法，从`FuncDef`语法成分中读取一个函数符号。
* 方法`getCallFuncSymbol(SyntaxClass unaryExp)`，静态方法，从`UnaryExp`且已确定为是函数调用的语法成分中读取一个函数符号。

`Exceptions/DuplicatedDefineIdentException.java`

* 重定义异常

`Exceptions/LValNotDefinedException.java`

* `LVal`内未定义符号异常

### 实现流程

#### 符号表结构

![](符号表结构.png)

符号表体系结构的设计参考了*Compilers: Principles, Techniques and Tools*一书中的设计。每一级一张独立的符号表，其`parent`指向其直接上一级符号表。全局符号表的`parent`指向`null`。

如此设计可以保证每次在一张符号表上能且只能看见该符号表本身及所有该符号表从属的符号表，看不见与其没有直接隶属关系的符号表。且在递归下降分析时，这类单向树符号表的行为与栈类似，能很好适应递归下降时的符号表操作。

在加入符号时，符号表仅扫描本表内是否有重名变量。在查找符号时，从本级开始逐级向上查找，找到最近的一个即可。这就满足了内部符号覆盖外部符号的要求。

#### 错误处理实现

| 错误类型 | 处理实现 |
| -------- | -------- |
| 非法符号 | 词法分析时检测到`FormatString`时就检测是否有非法字符，若有，则将错误加入错误列表。 |
|名字重定义|检测到当前是定义类型的语法成分时，将相应Token的内容在当前符号表内查询，若查询到有效记录则报错。|
|未定义名字|在`LVal`和`UnaryExp`检测到标识符时，在当前符号表要求全局查询，若查找不到则报错。|
|函数参数个数不匹配|在检查到函数调用时，确认函数符号有效及函数内各参数有效后，生成函数调用参量类型表，调用被调函数的符号的检查模块，检查参数个数是否匹配。|
|函数参数类型不匹配|完成参数个数检测且未报错后，调用被调函数的符号的检查模块，检查参数类型是否匹配。|
|无返回值函数存在不匹配return语句|检查到当前语句为return，则从符号表检查当前所在函数类型，然后与return类型比较，若不匹配，则报错。|
|有返回值函数缺少return语句|在执行完一次对`FuncDef`的读取后，若该函数为有返回值函数，则检查`Block`的最后一项语法成分是否为return语句。|
|改变`LVal`常量值|检查到对`LVal`赋值的语句，则去符号表中检查该`LVal`对应的Token，若为常量则报错。|
|缺少分号|递归下降检查时若在该出现分号时没有分号则报错。|
|缺少右小括号|递归下降检查时若在该出现右小括号时没有右小括号则报错。|
|缺少右中括号|递归下降检查时若在该出现右中括号时没有右中括号则报错。|
|printf中格式字符与表达式个数不匹配|在词法分析时就检查格式字符串中格式字符数，在读取到printf时检查后面表达式的数量是否与格式字符数匹配。|
|非循环块中使用break或continue|检查到break或continue时，在符号表中检查当前是否在循环块内，若不在则报错。|

### 设计修改

在存在回溯的递归下降部分，若简单地在产生错误处直接进行处理，会导致回溯后多次报告同一错误，因此在对如`LVal`等部分进行错误处理时，不再直接处理，而是记录错误情况，作为`Exception`抛出，交给上一层逻辑判断是否将本次报错加入已检测的错误列表。

某些部分如缺括号、缺分号之类进行错误处理后，后面的内容会因为检测不到前一处应有的符号而报错，因此在报错的错误处理部分把缺失的符号补回去了。

## 四、代码生成

### 程序架构

`IR/IRSymbol.java`

* 中间代码符号的interface。

`IR/IRImmSymbol.java`

* 中间代码立即数符号，其`value`属性即为该立即数的值。

`IR/IRLabelSymbol.java`

* 中间代码符号，可用于表示变量或地址
* 属性`id`，`int`类型，表示该符号的ID
* 属性`isGlobal`，`boolean`类型，表示是否是全局符号

`IR/IRFuncSymbol.java`

* 中间代码函数符号
* 属性`func`，`String`类型，表示函数名
* 属性`entry`，`IRSymbol`类型，表示函数入口标签
* 属性`fParamList`，`ArrayList<IRSymbol>`类型，表示形参表

`IR/IRArrSymbol.java`

* 中间代码数组元素符号
* 属性`baseAddr`，`IRSymbol`类型，表示基地址
* 属性`offset`，`IRSymbol`类型，表示偏移量

`IR/IRLabelManager.java`

* 中间代码符号管理器
* 属性`instance`，`IRLabelManager`类型，为单例模式的唯一实例
* 属性`labelMap`，`HashMap<Integer, IRLabelSymbol>`类型，记录其发放管理的符号ID和符号本身的关系
* 属性`cnt`，`int`类型，记录下一个发放符号的ID
* 方法`getIRLabelManager()`，单例模式下获取实例方法
* 方法`allocSymbol()`，向该管理器申请一个新符号，管理器返回一个新符号并记录该符号ID，然后将cnt自增1。

`IR/CompUnitSimplifyer.java`

* 表达式常量化简类

* 递归地查找`CompUnit`中的常量成分，并将其逐层计算得到常量部分的值

`IR/IRTranslater.java`

* 语法树到中间代码的翻译器

* 对各个语法成分有相应的分析方法
* 最终得到一列中间代码和全局数据信息

`FunctionTemplate.java`

* 运行时函数模板
* 用于确定该函数所需空间，以动态地调整运行时栈的位置
* 方法`getSymbolOffset`，接受一个符号，返回该符号在函数运行时相对于栈顶的偏移
* 方法`getTemplateSize`，返回该函数所需的空间大小，以字节为单位

`MIPSTranslater.java`

* 中间代码到MIPS目标代码的生成器
* 方法`buildFunctionTemplate`，对中间代码进行扫描，建立起各函数的模板
* 对各类中间代码指令的翻译方法

### 中间代码设计

#### 算术指令（允许立即数）

| 指令                             | 用途               |
| -------------------------------- | ------------------ |
| add \<dest\> \<op1\> \<op2\>     | op1 + op2          |
| minu \<dest\> \<op1\> \<op2\>    | op1 - op2          |
| mult \<dest\> \<op1\> \<op2\>    | op1 * op2          |
| div \<dest\> \<op1\> \<op2\>     | op1 / op2（整除）  |
| mod \<dest\> \<op1\> \<op2\>     | op1 % op2（取模）  |
| assign  \<dest\> \<op1\>         | dest = op1（赋值） |
| lshift \<dest\> \<op1\> \<op2\>  | op1 << op2         |
| rshift \<dest\> \<op1\> \<op2\>  | op1 >> op2，逻辑   |
| rashift \<dest\> \<op1\> \<op2\> | op1 >> op2，算术   |
| and \<dest\> \<op1\> \<op2\>     | op1 & op2          |

#### 逻辑指令

| 指令                          | 用途       |
| ----------------------------- | ---------- |
| gre  \<dest\> \<op1\> \<op2\> | op1 > op2  |
| geq  \<dest\> \<op1\> \<op2\> | op1 >= op2 |
| lss  \<dest\> \<op1\> \<op2\> | op1 < op2  |
| leq  \<dest\> \<op1\> \<op2\> | op1 <= op2 |
| eql  \<dest\> \<op1\> \<op2\> | op1 == op2 |
| neq  \<dest\> \<op1\> \<op2\> | op1 != op2 |

#### 控制流

| 指令                               | 用途                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| br \<label\>                       | 无条件跳转至 \<label\>（op3）                                |
| bz \<label\> \<op1\>               | 若op1为0则跳转至\<label\>（op3）                             |
| bnz \<label\> \<op1\>              | 若op1不为0则跳转至\<label\>（op3）                           |
| call \<ret\> \<func> \<ParamList\> | 返回值（op3，可为null），函数调用（op1），带参数列表（可空） |
| setret \<op3\>                     | 设置为返回值                                                 |
| ret                                | 函数返回                                                     |
| exit                               | main函数结束，程序结束                                       |

#### 内存操作

| 指令                          | 用途                                         |
| ----------------------------- | -------------------------------------------- |
| load \<op3\> \<op1\> \<op2\>  | 从op1为基地址，op2为偏移量处取值送op3        |
| store \<op3\> \<op1\> \<op2\> | 向op1为基地址，op2为偏移量处存op3            |
| alloca \<dest\> \<op1\>       | 开辟op1字节大小空间，基地址送dest（int需*4） |

#### 输入输出

| 指令               | 用途                        |
| ------------------ | --------------------------- |
| getint \<dest\>    | dest=getint()               |
| prints \<strdest\> | printf，带字符串地址（op3） |
| prints \<op3\>     | printf，带整数（op3）       |

#### 其他

| 指令                        | 用途                        |
| --------------------------- | --------------------------- |
| #\<id\>                     | 中间变量，编号为id          |
| func \<name\> \<paramlist\> | 函数定义（op3），带参数列表 |
| label \<LabelName\>         | 标签（op3）                 |

### 实现流程

在语法类中添加了标志是否进行求值的位和常量求值结果。在执行代码生成前，先使用`CompUnitSimplifyer`类对整个语法树递归地进行一次常量求值化简，可以得到各常量的值、数组大小等信息。

`IRTranslater`类是语法树到中间代码的翻译器。在`IRTranslater`中，翻译器维护了常量数组、全局变量、格式字符串和函数名与中间代码符号的映射表。同时还在前述符号表中维护了变量符号与对应的中间代码符号映射。

在每次读取到全局变量定义或局部数组定义时，插入申请空间的中间指令（`ALLOCA`）并将得到的基地址符号在相应映射表中记录。读取到函数定义时，在函数映射表中作记录。

在每次读取到变量被使用时，在当前符号表中检查是否已经有该变量对应的中间代码符号，若没有则申请一个新的。每次读取到变量被赋值或初始化时，若未开启SSA，则检查符号表是否有该符号，有就用原来的，没有则申请新的；若已开启SSA，则直接申请新符号并更新符号表中该变量对应的符号。

对于数组元素，设置了`IRArrSymbol`来表示数组元素。每次检测到对数组元素的使用，就在相应的表中查询数组符号，并计算得到表示偏移的符号，拼在一起作为一个`IRArrSymbol`实例使用。

对于普通的控制结构，参照语法制导翻译部分的方法，在相应位置插入中间代码符号，以一条`LABEL`类指令作为跳转地址标签。然后在相应的位置插入相应的跳转语句。

对于函数调用，在调用前按顺序插入计算各参数的指令，然后加入`CALL`指令，带上参数、函数名和返回值。

对于`printf`，在词法分析阶段建立格式字符串时已经将各部分划分好，因此直接将纯字符串部分和格式字符部分拆开，拆成对字符串的输出和对格式字符变量（整数）的输出，同时将字符串加入全局变量区。

对于条件语句，需要遵循短路求值的原则。因此，我实际上将复合的条件语句展开为了一段过程以及一个返回值。首先计算第一个条件，若第一个条件满足短路求值的要求，则跳转到设置返回值为1的部分，否则计算第二个条件，并跳转至设置相应返回值部分。

